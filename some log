9月10号 20:30 腾讯teg
9月11 20:00 58同城
9月11 11:00 百度
9月12 10:50-11:30 贝壳
9月14日 11:00 美团二面
9月16日 华为

cat /proc/sys/fs/file-max 来修改这里面文件的数目
ulimit -n 更改进程打开文件数目限制
/etc/security/limits.conf  修改配置，改变进程打开文件数目
/proc/sys/net/core/somaxconn  每个端口最大监听队列的长度
/proc/sys/net/ipv4/ip_local_port_range 修改端口范围
总的来说链接数目是不受限制的吧，应该无上限， 受打开文件的个数影响

408 rst，服务器主动断开，导致客户端请求返回408，rst

100 1.1以后post分两段发送
200 成功，数据跟随返回
201 请求成功创建新的资源，url返回了，资源没返回
202 服务器接受请求，尚未处理
301 永久重定向
302 临时重定向
303 资源改了url，应使用get
304 网页访问过且没变化，不返回资源
307 临时重定向 不强制使用get
400 服务器不理解请求的语法
401 身份验证，需要登录
403 服务器拒绝执行
404 链接不存在，没有这个资源
408 rst，服务端主动关闭了我们再去请求
500 服务端出错
502 防止机器过载
503机器过载，一会儿恢复

accept惊群问题已经解决（内核保证只唤醒一个），epoll惊群问题没有解决，
fork之后共享文件描述符，都用epoll监听就发生了惊群问题，多个都会被唤醒。

rabbitmq 消息队列

sql笛卡尔积，一般是指连接查询时没有得到正确的结果，一般来说加上join，直接换有效的位就行了，什么等于什么就可以了，这样可以避免笛卡尔积，或者说不连接查询了，直接select两次

limit 数值很大，就需要回表很多次，而且只取很少，可以把主建先取出来，然后再取回表，少了n次回表，优化了很多

float/double
存储浮点数 0/1  8/11（127 1023）  23/52 位的存储方式来存储浮点数，先转成二进制，再转成科学技术法
10       10                12
先分页在分段，物理地址 线性地址(分页) 逻辑地址(分段)

runid（唯一） 和 offset（偏移量）
主节点保存所有从节点的offset（命令字节长度），用来判断数据的一致性
repl_backlog_size 默认1M的缓冲区，不在这个缓冲区说明肯定持久化了，得全量同步

主从runid大小不一样，或者第一次启动时，或者积压缓冲区不够offset的差距 全量复制（RDB）
增量复制给的是命令
从节点启动时会给主节点发自己保存的runid和offset，不一致时应该也要发吧我觉得

定时过期，惰性过期，定期过期

数据库实现分布式锁
redis实现分布式
zookeeper实现分布式锁

中止策略            丢弃任务并抛出异常，可以及时通知
丢弃策略		 直接丢弃任务，不抛出异常      比如访问量什么的，粗略数字
弃老策略		 扔掉队列里面最前面的任务      发布消息
调用者运行策略    由调用线程处理该任务            不允许失败的场景，一定要执行

小根堆跟我们vector重载不一样，vector<是从小到大，而堆<是从大到小，跟vector是反的

vector 是两倍扩容，还有1.5倍扩容

大量time_wait 设置msl时间，增大连接数，重用time_wait,  短链接变成长链接，业务优化

自然连接  不用指定列也不能使用ON语句，默认比较两张表里相同的列
内连接      隐士的内连接/显示的内连接    没有INNER JOIN  有INNER JOIN ON进行塞选，相当于笛卡尔积
外连接     左外连接/右外连接/全外连接/  mysql使用union来实现  left join right join
交叉连接  


优化多线程上下文切换
锁竞争
数据拷贝
环境切换
内存分配

第一范式(确保每列保持原子性)                                        原子性
第二范式(确保表中的每列都和主键相关)                            完全依赖于主键
第三范式(确保每列都和主键列直接相关,而不是间接相关)       直接依赖于主键

内部碎片 占用了不使用，分配不了
外部碎片 内存空间太小分不出去

redlock
据说还是会丢一条数据
always
ererysec
no

代码写起来也简单
在做范围查找的时候，平衡树比skiplist操作要复杂。
平衡树需要以中序遍历的顺序继续寻找其它不超过大值的节点。
skiplist进行范围查找非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
skiplist需要更少的指针内存。平均每个节点包含1.33个指针，比平衡树更有优势。

dynamic_cast 使用场景底层原理
dynamic_cast怎么知道对象是谁new的
linux下把我的地址通过socket传给另个进程，那个进程能读到我的东西吗

虚拟地址页和操作系统怎么映射的   存在cpu的MMU内存管理单元里面，按理来说是段页式存储，先分页在分段，但是linux只是分页，以4kb为基本单位。
映射的数据结构存在哪里 ----cpu MMU内存管理单元
10页目录 10表项 12偏移量

map  key为对象时重载什么东西 < 
unordered_map key为对象时重载什么东西 重载哈希函数，同时需要注意对象不同但是哈希函数结果相同的场景，怎么处理
c++ placement new 重载new分配内存，每次内存的其实地址都是256的倍数
epoll内核怎么做的
select底层
shared_ptr使用场景，为什么不用unique_ptr，shared_ptr底层记数怎么实现的
自定义对象的vector，他们的data可以直接memcpy吗，为什么了
场景题：很难，不会


内存碎片 
内部碎片 是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以完全避免；
外部碎片 是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。
内存的分页机制解决了外部碎片，但是仍然有内部碎片的问题需要解决，但是量也不大。

先来先服务 fcfs
轮转法   		  轮着执行
最短进程有限       非抢占
最短时间优先	  抢占
优先级调度		  根据优先级调度
多级反馈队列调度  就是说有多个队列，每个队列优先级不一样，运行过程中反馈优先级，优先级低了就扔到下一个队列
高响应比优先   (w+s) / s 响应比高优先

可重入函数 不用什么全局变量或者静态变量的函数，他中断去执行其他程序之后回来不会影响执行结果，可以安全的继续执行

gprof  gdb -pg 得到文件，用gprof来获取执行时间，调用关系等东西
gstack pid 查看运行进程的堆栈信息
bt/backtrace gdb bt或者函数里写backtrace函数调用栈
dump_stack linux系统调用，函数调用栈

cap理论 一致性 可用性 分区容错性
分布式事物 
2pc 协调者 参与者 所有参与者，不然回滚  事物请求 事物提交/回滚
3pc cancommit询问能不能提交 precommit预提交/回滚 docommit 真正的提交/回滚

proposer acceptor  learner
多个acceptor提议选取者，规定每个只能选取一个propose，确保只会有一个propose被选中
规定：1. 必须批准收到的第一个提案
提案 = [编号，value]
。。。
paxos主要提出了过半同意这个概念
两个阶段 prepare promise

zookeeper
term index myid文件里的serverid编号，越大越好
强一致性，写效率降低，需要写commit
LOOKING
FOLLOWING
LEADERING
OBSERVING

发布订阅
客户端向服务端注册自己关注的节点，一旦节点数据变化，就通过watcher事件通知客户端，客户端需要主动到服务端获取节点最新的数据

分布式锁
互斥锁---创建同一个节点，只有一个可以成功
共享锁---编号，写锁等待前面的所有结束了，读锁等待上一个写锁结束了，避免羊群效应，注意监听范围

shared_ptr make_shared和直接构造函数

redis
string  sds.h sds.c 跟c++string比较像吧，兼容char*，int(长度不超过20，还缓存了10000个整型值，大小不超过10000的同一个对象，节约内存) raw(大于44，申请两次内存，释放两次，不连续，sds单独申请) embstr(内存连续,大小固定，只释放一次内存，只申请一次）
set  value为空的hash
sorted set 有序set
list 列表
hash 字典
bitmap geohash(二分得到25位，base32编码成字符串) HyperLogLog(数组去重) streams

ziplist
skiplist 跳表
linkedlist
hashtable
intset  有序数组
hashtable

雪崩 缓存大量失效              缓存随机时间失效，非一次性失效，定时失效，失效里选一批失效
击穿 某个热点缓存失效        设置失效，失效时加锁，缓存写好了才让大多数人进来读
穿透 越过了缓存，没有找到    布隆过滤器，或者设置空缓存，时间1-2分钟

熔断             下游服务器可用性影响到上游，不再调用下游，直接返回
服务降级       比如某些不重要服务不要了，保证主要服务可用性
快速失败       流量太大，解决不了的时候快速失败，直接返回
负载均衡算法
缓存淘汰策略 fifo lru lfu

数据库锁
悲观锁和乐观锁
行锁，表锁， 页锁

mysaim只有表锁，读写锁
InnoDB使用索引的条件
1.在不通过索引条件查询的时候，InnoDB 确实使用的是表锁，而不是行锁。
2.行锁是针对索引加锁，不是针对记录加的锁。即使访问的是不同行，但如果它们索引相同，还是会出现锁冲突。
3.当表中含有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行。
4.即使在条件中使用了索引，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价决定的。如果 MySQL 认为全表扫描效率更高，比如很小的表，也不会使用索引，此时 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突的时候，不要忘记检查 SQL 的执行计划，以确定是否真正使用了索引。

执行查询语句（ SELECT ）前，由于 MVCC（多版本控制）的方式，什么锁都不会加。
在执行更新操作（ UPDATE、DELETE、INSERT 等）前，会自动给涉及的行加写锁，此时会阻塞其他用户的写操作，但是通过 MVCC（多版本控制）的方式允许读操作。（竟然可以读）

RR解决幻读 next-key（使用索引时才会生效，select*是解决不了幻读的），RC解决幻读 MVCC

linux常用命令
netstat -antp ｜ grep ... 通过端口找进程
ps -ef ｜ grep ... 查找进程
df -h 磁盘情况
du -h 查看当前目录各个子目录，文件大小
free
top 1 5 15 负载率 等待进程数目
使用率 按1排序
wc -clw 字节数行数单词数
awk -F"=" {print $1} "hahahah="

awk '{print "a"}'   /etc/passwd 输出相同行数，每行一个a
awk -F= '{print $1}' nuwa_reconfig.LOG 按=切割，输出第一个 

find . -name .../"*.."
s/Vim/vim/g  全局替换

保留区0-4k
代码段（常量区）
数据段
bss
堆
文件映射区
栈
int main(int argc, char **argv) 参数和环境变量
内核区

协程就是函数栈，分时调用，避免线程开销，保留了函数的运行栈，可以过一会儿再回来继续运行
MPG模型
M代表工作线程，每个M与一个内核线程对应
P代表处理器，就是执行协程的地方
G代表的是协程，里面保存了协程的栈，程序计数器等资源
seched 调度器，调度P,M,G的资源

虚拟内存：32位电脑4g虚拟内存
虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

用户态
内核态

mysql数据库锁
Record lock:记录锁，单个行记录上的锁  唯一索引进行数据检索
Gap lock：间隙锁，锁定一个范围，但不包含记录本身
锁定索引记录间隙，确保索引记录的间隙不变
间隙锁时针对事务隔离级别为可重复读或以上级别而配的
Next-key lock：record+gap，锁定一个范围，且包含记录本身，只出现在RR解决部分幻读问题
当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。
当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。

epoll_create
epoll_ctrl
epoll_wait
socket

shmat
shmdt
shmctrl
shmget

匿名管道有名管道消息队列信号量共享内存信号 socket
socket accept对应tcp三次握手什么时候

sig_ign(sigpipe, sig_ign) 忽略信号，也可以将信号给函数处理一下
对象的函数需要&，非对象函数并不需要

僵尸线程 子线程挂掉富进程不wait，浪费进程pid等资源

geohash 计算得出相应的位数，变成对应的位数5个一组，然后用base32来进行编码，得到编码后的结果，以string形式存放

hyperloglog 基数估算，不实际存储元素的数目，只计算数目

kafka 分布式消息队列，大数据

dump_stack
backtrace 三个函数

gdb bt

ps -aux可以看到线程的cpu使用率

1.建立调试关系：
用gdb调试程序有2种模式，包括使用gdb启动程序，以及attach到现有进程。分别对应下面2种建立调试关系的方法：
1)  fork: 利用fork+execve执行被测试的程序，子进程在执行execve之前调用ptrace(PTRACE_TRACEME)，建立了与父进程(debugger)的跟踪关系。

2)  attach: debugger可以调用ptrace(PTRACE_ATTACH，pid,...)，建立自己与进程号为pid的进程间的跟踪关系。即利用PTRACE_ATTACH，使自己变成被调试程序的父进程(用ps可以看到)。用attach建立起来的跟踪关系，可以调用ptrace(PTRACE_DETACH，pid,...)来解除。注意attach进程时的权限问题，如一个非root权限的进程是不能attach到一个root进程上的。

2.断点原理：
1)    断点的实现原理，就是在指定的位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并进行断点命中判定，当gdb判断出这次SIGTRAP是断点命中之后就会转入等待用户输入进行下一步处理，否则继续。 
2)    断点的设置原理: 在程序中设置断点，就是先将该位置的原来的指令保存，然后向该位置写入int 3。当执行到int 3的时候，发生软中断，内核会给子进程发出SIGTRAP信号，当然这个信号会被转发给父进程。然后用保存的指令替换int3,等待恢复运行。
3)    断点命中判定:gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。
4)    条件断点的判定:原理同3)，只是恢复断点处的指令后，再多加一步条件判断。若表达式为真，则触发断点。由于需要判断一次，因此加入条件断点后，不管有没有触发到条件断点，都会影响性能。在x86平台，某些硬件支持硬件断点，在条件断点处不插入int 3，而是插入一个其他指令，当程序走到这个地址的时候，不发出int 3信号，而是先去比较一下特定寄存器和某个地址的内容，再决定是否发送int 3。因此，当你的断点的位置会被程序频繁地“路过”时，尽量使用硬件断点，会对提高性能有帮助。

3.单步跟踪原理：
这个最简单，因为ptrace本身支持单步功能，调用ptrace(PTRACE_SINGLESTEP，pid,...)

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
GET在浏览器回退时是无害的，而POST会再次提交请求
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET参数通过URL传递，POST放在Request body中。


立即删除 惰性删除 定时删除

buffer/caffe 磁盘缓冲区
total/used/free/shared/available/swap

sql笛卡尔积 相互乘起来
左连接：只要左边表中有记录，数据就能检索出来，而右边有的记录必要在左边表中有的记录才能被检索出来。
右连接：右连接是只要右边表中有记录，数据就能检索出来

linux栈帧默认为8M吧，ulimit -s 。。 来改变栈帧的大小

单例模式
工厂模式
Impl模式         class前置声明  但是不能直接调用方法
责任链模式
观察者模式      订阅
装饰器模式      登陆功能扩展成为qq，微信登陆
适配器模式      deque变成栈和队列


Nagle 会等待满了在一起发送出去，关闭之后就会有发的就发出去了

将redis用做缓存是一种非常常见的手段，然而由于内存大小的限制，会导致redis在内存空间满了以后需要处理继续存入的数据。总计有以下几种策略：
volatile-ttl：在设置了过期时间的数据集里，淘汰离过期时间最近的key。
volatile-random：在设置了过期时间的数据集里，淘汰任意一个key。
volatile-lru：在设置了过期时间的数据集里，淘汰最近最不常使用的key。
allkeys-random：在所有数据集里，淘汰任意一个key。
allkeys-lru：在所有数据集里，淘汰最近最不常使用的key。
noeviction：返回报错。

协议，本地地址，本地端口号，远地地址，远地端口号

new placementnew nothrownew
new (std::nothrow) Manager();
listen backlog  全连接队列数目（socket）
somaxconn 内核级别队列长度
半连接队列长度 = min(backlog, 内核参数 net.core.somaxconn，内核参数 tcp_max_syn_backlog) 半连接队列长度是不能超过全连接队列长度的
